Aula 1 - O que é integração contínua ?

Entendendo o problema:

Um software é desenvolvido por uma equipe que está gerando alterações e commits. 
A integração contínua (IC ou CI) é uma prática que requer dos desenvolvedores 
integrar códigos em um repositório compartilhado várias vezes ao dia.

Benefícios da Integração Contínua:

	As falhas são detectadas mais rapidamente
	Integrações mais simples
	
O que deve ser guardado no repositório?

	Script de testes
	Databae Schema
	
Sistemas de controle de versão:

Em uma equipe de desenvolvimento, precisaremos de uma ajuda para sincronizar e manter o histórico do código, de maneira concreta utilizamos ferramentas como Git e SVN.

A integração contínua não possui necessidade de muitas ferramentas, em tese, mas alguns auxílios que são padrão em práticas de desenvolvimento são requiridos.

O Git é o mais popular em integração hoje em dia, mas não precisamos utiliza-lo, basta que tenhamos algum modelo de controle de versão de nossa escolha.

A ferramenta em si não importa, mas o que devemos inserir em nosso sistema de controle? De maneira geral, deve conter tudo aquilo que é necessário para a construção do projeto.

    código
    scripts
    migrações, schemas
    IDE Configs

Devemos definir uma formatação de código para a equipe. Para começarmos um projeto é necessário fazer o clone - a cópia local - e o comando unificado. 

Não deve ser "comitado" o que pode ser construído. Resultados da construção do software não são comitados como como gem, jar, image e modules. 
	
Organização de repositórios

	Multi-repo: Cada projeto com um repositório (mais comum)
	Mono-repo: Muitos projetos em um único repositório
	
	Em comparação ao Mono-Repo, quais são as vantagens do *Multi-repo são:
	
	- Possibilidade de definir permissões de acesso por projeto
	- Clone, commit e build do projeto simples e rápido
	
Aula 2 - Estratégias de ramificação

	
	Branching Models / Strategy / Policy
	
		/---------o BRANCH "Desenvolvimento" 
	o--/--o----o-----o MASTER
					\--------o---o--o BRANCH "Release"
	
	
	Ramos para funcionalidades distintas do projeto.
	
	Exemplos de fluxos ou modelos de ramificação:
	
	git flow
	github flow
	gitlab flow
	pull request flow
	one flow
	feature branch flow
	
	
	Uma BRANCH (ramificação) MASTER deve representar o estado da aplicação.
	
	Boas práticas:
	
		Commits simples e lancáveis, orientado às tarefas
		
		Branches atrasam integração contínua, seguram o código
		
		Branches de vida curta implicam em merges mais simples
		
		Quanto mais Branches mais burocracia
		
		Estratégias devem ser combvinadas pela equipe
		
	
	Branch Models:
	
	- Temporários (branches locais) São branches localizados apenas na máquina local e deverão se extiguir, são utilizados para organizar fluxos de trabalho e depois realizar o commit.

	- Feature (MASTER e FEATURE) Branches São utilizados para implementar funcionalidades ou orientar tarefas.

	- Historical Branches (mastaer e develop) As alterações ficam organizadas em commits baseados na cronologia no caso de um projeto de software.

	- Environment Branches (Staging e Production)] Existem branches que são baseados no ambiente, isto é, em que espaço é realizado o deploy.

	- Maintenance Branches (Release e Hotfix) Temos, ainda, os branches de manutenção do sistema. 
	
	
	Exemplo
		
	Feature Branch + Pull Request ->  Exemplo Github Flow
	
	Você precisa escolher um modelo de ramificação para uma equipe nova. Há duas características que precisam ser seguidas:

    As novas funcionalidades devem ser implementadas em uma nova branch
    Cada funcionalidade deve ser revisada pela equipe antes de entrar no mainline 

	Qual modelo de ramificação você sugeria?
	O GitHub Flow é um modelo leve, desde que as features branches sejam de vida curta (poucos dias).
	Também devemos ter em mente que os pull requests podem ser uma barreira para a integração contínua.
	
	Como evitar branches de vida longa?
	
	Feature Flag
	
	Branch by abstraction
	
	
	Como sincronizar branches?
	
	Merge ou Rebase?
	
	rebase:  
	O rebase sincroniza/pega os commits da outra branch e reaplica os novos commits da branch atual. Dessa forma, ele reescreve o histórico da branch atual.
	
	Esse é a grande vantagem do rebase. Os commits aparecem como eles fossem executados um após do outro.
			
	
			

	

		
	
	